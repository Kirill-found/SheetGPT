# SheetGPT v7.8.0 - Hybrid Intelligence Architecture

## Проблема v7.7.0

❌ **Pattern Detection превратил систему в "бота со скриптом"**
- Добавление каждого нового паттерна = новый if-else
- Система НЕ размышляет, а только сравнивает со списком правил
- Это путь к хрупкой системе, которая ломается на новых запросах

## Решение v7.8.0 - Hybrid Intelligence

✅ **3-уровневая система с интеллектом на каждом уровне**

```
┌─────────────────────────────────────────────────┐
│  TIER 1: Pattern Detection (10-15 паттернов)   │
│  Цель: Мгновенный ответ на частые запросы      │
│  Токены: 0                                      │
│  Время: <100ms                                  │
└─────────────────────────────────────────────────┘
                    ⬇ (если паттерн не найден)
┌─────────────────────────────────────────────────┐
│  TIER 2: Query Classifier (GPT-4o-mini)        │
│  Цель: Определить сложность запроса            │
│  Токены: ~100                                   │
│  Время: ~200ms                                  │
│  Решение: simple → TIER 3A, complex → TIER 3B  │
└─────────────────────────────────────────────────┘
                    ⬇
         ┌──────────┴──────────┐
         ⬇                     ⬇
┌──────────────────┐   ┌──────────────────┐
│  TIER 3A         │   │  TIER 3B         │
│  Function Call   │   │  Code Generation │
│  (GPT-4o)        │   │  (GPT-4o)        │
│  ~500 tokens     │   │  ~1000 tokens    │
│  ~95% точность   │   │  ~99% точность   │
└──────────────────┘   └──────────────────┘
```

## Преимущества Hybrid подхода

### 1. Интеллект вместо скриптов
- GPT-4o **понимает** запрос, а не сравнивает с паттернами
- Система **размышляет** о том, как решить задачу
- Pattern Detection используется только для 10-15 самых частых случаев

### 2. 99% точность
- Простые запросы → Function Calling (быстро, надёжно)
- Сложные запросы → Code Generation (гибко, универсально)
- **GPT сам выбирает подход** через Query Classifier

### 3. Экономия токенов
- TIER 1: 0 токенов для 30-40% запросов
- TIER 2: Только 100 токенов на классификацию
- TIER 3: Оптимальный подход (Function Call дешевле Code Generation)

### 4. Расширяемость
- Добавление нового паттерна = 3 строки кода
- Добавление новой функции = просто добавить в registry
- Code Generation справляется с ЛЮБЫМИ новыми запросами

## Примеры работы

### Пример 1: "топ 3 заказа в Москве"

```
TIER 1 (Pattern Detection):
  ✅ Паттерн найден: r"топ (\d+) .* в (\w+)"
  → filter_top_n(df[df['Город']=='Москва'], 'Сумма', 3)
  Результат: мгновенный (0 токенов)
```

### Пример 2: "Сколько оплаченных заказов у каждого менеджера?"

```
TIER 1 (Pattern Detection):
  ❌ Паттерн не найден (слишком специфичный)

TIER 2 (Query Classifier):
  Query: "Сколько оплаченных заказов у каждого менеджера?"
  GPT-4o-mini: "simple" (одна операция группировки + фильтр)

TIER 3A (Function Calling):
  ✅ aggregate_by_group(
       df[df['Статус']=='Оплачен'],
       group_by=['Менеджер'],
       agg_func='count'
     )
  Результат: правильно (~500 токенов)
```

### Пример 3: "Найди заказы выше среднего в каждом городе и выдели топ менеджера"

```
TIER 1 (Pattern Detection):
  ❌ Паттерн не найден (сложный запрос)

TIER 2 (Query Classifier):
  Query: "Найди заказы выше среднего в каждом городе и выдели топ менеджера"
  GPT-4o-mini: "complex" (требует нескольких операций)

TIER 3B (Code Generation):
  GPT-4o генерирует Python код:
  ```python
  city_avg = df.groupby('Город')['Сумма'].mean()
  df['above_avg'] = df.apply(lambda r: r['Сумма'] > city_avg[r['Город']], axis=1)
  high_orders = df[df['above_avg']]
  top_manager = high_orders.groupby('Менеджер')['Сумма'].sum().idxmax()
  result = {
      'high_orders': len(high_orders),
      'top_manager': top_manager,
      'total': high_orders['Сумма'].sum()
  }
  ```
  ✅ Код выполняется → правильный результат (~1000 токенов)
```

## Критерии TIER 1 (Pattern Detection)

**Включаем ТОЛЬКО самые частые паттерны (10-15 штук):**

```python
TIER1_PATTERNS = [
    r"топ (\d+)",                    # "топ 3 заказа"
    r"худш\w+ (\d+)",                # "худшие 5 клиентов"
    r"у каждого (\w+)",              # "у каждого менеджера"
    r"сколько (всего|оплач)",        # "сколько всего заказов"
    r"средн\w+ (\w+)",               # "средняя сумма"
    r"сумма (всех|оплач)",           # "сумма всех заказов"
    r"макс\w+ (\w+)",                # "максимальная сумма"
    r"мин\w+ (\w+)",                 # "минимальная сумма"
    r"найди (\w+) где (\w+) = (.+)", # "найди заказы где статус = Оплачен"
    r"сортировать по (\w+)",         # "сортировать по сумме"
]
```

**Правило:** Если паттерна нет в списке → передаём GPT.

## Критерии TIER 2 (Query Classifier)

**GPT-4o-mini определяет сложность:**

```python
SIMPLE_QUERIES:
  - Одна операция (сумма, среднее, топ-N, фильтр)
  - "сумма всех заказов"
  - "топ 5 клиентов по выручке"
  - "средняя цена товаров"

COMPLEX_QUERIES:
  - Несколько операций подряд
  - Условная логика (if-else)
  - Вычисления внутри групп
  - "найди заказы выше среднего в каждом городе"
  - "сравни средние суммы по менеджерам и выдели лучшего"
```

## Критерии TIER 3A vs 3B

**TIER 3A (Function Calling)** - используется когда:
- Query Classifier определил "simple"
- Запрос решается одной функцией из 20 core functions
- Нужна скорость и экономия токенов

**TIER 3B (Code Generation)** - используется когда:
- Query Classifier определил "complex"
- Требуется несколько операций
- Нужна гибкость и универсальность

## Метрики успеха v7.8.0

| Метрика | Целевое значение |
|---------|------------------|
| Точность TIER 1 | 100% (детерминированный) |
| Точность TIER 3A | 95%+ (Function Calling) |
| Точность TIER 3B | 99%+ (Code Generation) |
| Общая точность | 98%+ |
| Покрытие TIER 1 | 30-40% запросов |
| Средние токены | <600 (экономия 40% vs v7.7.0) |
| Время ответа | <2s (TIER 1: <100ms) |

## Реализация

### 1. Query Complexity Classifier (app/services/query_classifier.py)

```python
async def classify_query_complexity(query: str, columns: List[str]) -> str:
    """
    Использует GPT-4o-mini для определения сложности запроса
    Returns: "simple" или "complex"
    """
    prompt = f"""
    Оцени сложность запроса для pandas DataFrame.

    SIMPLE - решается одной функцией:
    - "сумма всех заказов"
    - "топ 5 клиентов"
    - "средняя цена"

    COMPLEX - требует нескольких операций:
    - "найди заказы выше среднего в каждом городе"
    - "сравни средние суммы и выдели лучшего"

    Query: {query}
    Columns: {columns}

    Ответь ТОЛЬКО одним словом: simple или complex
    """

    response = await openai_client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        temperature=0
    )

    return response.choices[0].message.content.strip().lower()
```

### 2. Code Generation Engine (app/services/code_generator.py)

```python
async def generate_and_execute_code(query: str, df: pd.DataFrame) -> Dict[str, Any]:
    """
    Генерирует Python код с помощью GPT-4o и безопасно выполняет его
    """
    prompt = f"""
    Напиши Python код для pandas DataFrame, который решает этот запрос.

    Query: {query}
    Columns: {df.columns.tolist()}
    Sample data (first 3 rows):
    {df.head(3).to_dict('records')}

    ТРЕБОВАНИЯ:
    1. Используй ТОЛЬКО pandas и стандартные библиотеки
    2. DataFrame доступен как переменная 'df'
    3. Сохрани результат в переменную 'result'
    4. НЕ используй print(), только вычисления
    5. result может быть: число, строка, dict, или DataFrame

    Пример:
    ```python
    result = df[df['Статус']=='Оплачен']['Сумма'].sum()
    ```

    Верни ТОЛЬКО код, без объяснений.
    ```python
    """

    response = await openai_client.chat.completions.create(
        model="gpt-4o",
        messages=[{"role": "user", "content": prompt}],
        temperature=0
    )

    code = extract_code_from_response(response.choices[0].message.content)

    # Безопасное выполнение
    result = execute_code_safely(code, {"df": df, "pd": pd})

    return format_code_result(result, code, query)
```

### 3. Hybrid Processor (app/services/ai_function_caller.py)

```python
async def process_query_hybrid(self, query: str, df: pd.DataFrame, ...) -> Dict[str, Any]:
    """
    v7.8.0: Hybrid 3-Tier Architecture
    """

    # TIER 1: Pattern Detection
    pattern_result = self._detect_common_pattern(query, df)
    if pattern_result:
        logger.info("[TIER 1] Pattern Detection - 0 tokens")
        return pattern_result

    # TIER 2: Query Classifier
    complexity = await classify_query_complexity(query, df.columns.tolist())
    logger.info(f"[TIER 2] Query classified as: {complexity}")

    if complexity == "simple":
        # TIER 3A: Function Calling
        logger.info("[TIER 3A] Function Calling")
        return await self._function_calling_approach(query, df, column_names, custom_context)
    else:
        # TIER 3B: Code Generation
        logger.info("[TIER 3B] Code Generation")
        return await generate_and_execute_code(query, df)
```

## Миграция с v7.7.0 на v7.8.0

1. Сохранить Pattern Detection, но ограничить 10-15 паттернами
2. Добавить Query Classifier (GPT-4o-mini)
3. Добавить Code Generator (GPT-4o)
4. Интегрировать 3-tier decision system
5. Обновить логирование и метрики

## Тестирование

### Test 1: TIER 1 (Pattern Detection)
```python
"топ 3 заказа в Москве" → должен вызвать Pattern Detection (0 токенов)
```

### Test 2: TIER 3A (Function Calling)
```python
"Сколько оплаченных заказов у каждого менеджера?" → должен вызвать Function Calling (~500 токенов)
```

### Test 3: TIER 3B (Code Generation)
```python
"Найди заказы выше среднего в каждом городе и выдели топ менеджера" → должен сгенерировать код (~1000 токенов)
```

## Ожидаемые результаты

✅ **Интеллект**: Система размышляет, а не сравнивает со списком правил
✅ **Точность**: 98%+ благодаря Code Generation для сложных запросов
✅ **Скорость**: 30-40% запросов через TIER 1 (<100ms)
✅ **Экономия**: Классификатор стоит дёшево, но экономит дорогие вызовы GPT-4o
✅ **Расширяемость**: Новые запросы автоматически обрабатываются через Code Generation
